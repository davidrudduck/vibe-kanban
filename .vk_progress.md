# Open Terminal Feature - Implementation Progress

## Status: in-progress

## Overview
Adding an in-browser terminal that can be opened in:
1. Project root folder (from Project cards/details)
2. Worktree folder (from Task Attempt actions)

This is a web-based terminal rendered with xterm.js, connected to a backend PTY/shell session.

## Session 1: Backend - Terminal Session Manager âœ…

### Completed Items
- [x] Added `portable-pty = "0.8"` dependency to `crates/services/Cargo.toml`
- [x] Created `crates/services/src/services/terminal_session.rs`
- [x] Implemented `TerminalSessionManager` with:
  - `detect_tmux()` - Check if tmux binary is available
  - `generate_session_id(path)` - Deterministic session ID from path (SHA256)
  - `create_session(path)` - Create tmux or PTY-based session
  - `write_to_session(id, data)` - Write data to session
  - `resize_session(id, cols, rows)` - Resize terminal dimensions
  - `kill_session(id)` - Kill and cleanup session
  - `subscribe(id)` - Get broadcast receiver for session output
  - `list_sessions()` - List all active sessions
  - `get_session(id)` - Get session info
  - `attach_session(id)` - Reattach to existing tmux session
- [x] Implemented dual-mode backend:
  - **Tmux mode** (preferred): Persistent sessions that survive page refresh
  - **PTY fallback**: Ephemeral sessions when tmux unavailable
- [x] Added session output broadcasting via `tokio::sync::broadcast`
- [x] Registered module in `services/mod.rs`
- [x] All 17 unit tests passing
- [x] Clippy passes with no warnings

### Files Changed
| File | Change |
|------|--------|
| `crates/services/Cargo.toml` | Added `portable-pty = "0.8"` dependency |
| `crates/services/src/services/mod.rs` | Added `pub mod terminal_session;` |
| `crates/services/src/services/terminal_session.rs` | New file with TerminalSessionManager implementation |

### Test Results
```text
running 17 tests
test services::terminal_session::tests::test_detect_tmux_available ... ok
test services::terminal_session::tests::test_generate_session_id ... ok
test services::terminal_session::tests::test_get_session_not_found ... ok
test services::terminal_session::tests::test_list_sessions_empty ... ok
test services::terminal_session::tests::test_manager_clone ... ok
test services::terminal_session::tests::test_manager_initialization ... ok
test services::terminal_session::tests::test_create_duplicate_session ... ok
test services::terminal_session::tests::test_session_exists ... ok
test services::terminal_session::tests::test_session_id_is_deterministic ... ok
test services::terminal_session::tests::test_session_info_serialization ... ok
test services::terminal_session::tests::test_session_not_found ... ok
test services::terminal_session::tests::test_create_session_in_directory ... ok
test services::terminal_session::tests::test_terminal_error_display ... ok
test services::terminal_session::tests::test_kill_session ... ok
test services::terminal_session::tests::test_resize_session ... ok
test services::terminal_session::tests::test_write_to_session ... ok
test services::terminal_session::export_bindings_sessioninfo ... ok

test result: ok. 17 passed; 0 failed; 0 ignored
```

### API Summary
```rust
pub struct TerminalSessionManager {
    sessions: DashMap<String, Arc<RwLock<TerminalSession>>>,
    use_tmux: bool,
    tmux_path: Option<PathBuf>,
}

impl TerminalSessionManager {
    pub fn new() -> Self;
    pub async fn init(&mut self) -> &mut Self;
    pub async fn detect_tmux() -> bool;
    pub fn generate_session_id(path: &Path) -> String;
    pub async fn create_session(&self, working_dir: &Path) -> Result<String, TerminalError>;
    pub async fn write_to_session(&self, session_id: &str, data: &[u8]) -> Result<(), TerminalError>;
    pub async fn resize_session(&self, session_id: &str, cols: u16, rows: u16) -> Result<(), TerminalError>;
    pub async fn kill_session(&self, session_id: &str) -> Result<(), TerminalError>;
    pub async fn subscribe(&self, session_id: &str) -> Result<broadcast::Receiver<TerminalOutput>, TerminalError>;
    pub async fn list_sessions(&self) -> Vec<SessionInfo>;
    pub async fn get_session(&self, session_id: &str) -> Option<SessionInfo>;
    pub fn session_exists(&self, session_id: &str) -> bool;
    pub fn session_count(&self) -> usize;
    pub fn is_using_tmux(&self) -> bool;
    pub async fn attach_session(&self, session_id: &str) -> Result<(), TerminalError>;
}
```

## Remaining Sessions

### Session 2: Backend - WebSocket Route
- [ ] Create `crates/server/src/routes/terminal.rs`
- [ ] Add routes:
  - `POST /api/terminal/sessions` - Create session
  - `WS /api/terminal/{session_id}` - Bidirectional WebSocket
- [ ] Message types: Input, Output, Resize, Exit
- [ ] Register routes in router

### Session 3: Frontend - xterm.js Component
- [ ] Add dependencies: `@xterm/xterm`, `@xterm/addon-fit`
- [ ] Create `TerminalView.tsx` component
- [ ] Create `useTerminalWebSocket.ts` hook
- [ ] Wire xterm.js to WebSocket

### Session 4: Frontend - UI Integration
- [ ] Add terminal button to Navbar
- [ ] Add terminal toggle to AttemptHeaderActions
- [ ] Add 'terminal' mode to ProjectTasks
- [ ] Render TerminalView when mode is terminal

### Session 5: Frontend - Tabbed Interface
- [ ] Create TerminalsPanel component
- [ ] Create useTerminalTabs hook
- [ ] Support multiple terminal tabs
- [ ] Add/close terminal tabs

### Session 6: Session Persistence & Reconnection
- [ ] GET /api/terminal/sessions endpoint
- [ ] Auto-reconnect to existing sessions
- [ ] Reconnection UI indicator

### Session 7: Mobile & Polish
- [ ] Swipe gesture support
- [ ] Connection error UI
- [ ] Terminal settings
- [ ] Mobile device testing

### Session 8: Integration Testing & Cleanup
- [ ] E2E tests for terminal functionality
- [ ] Code cleanup
- [ ] Documentation update

## Next Steps
1. Create WebSocket route for terminal I/O (Session 2)
2. Wire up the terminal session manager to the deployment state
3. Implement bidirectional WebSocket communication
